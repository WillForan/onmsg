#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This code is largely based on
# http://www.cocoaforge.com/viewtopic.php?f=45&t=20355
# http://yuji.wordpress.com/2011/06/22/python-imaplib-imap-example-with-gmail/
# was also very helpful.
#
# It will exit with an error occasionally due to dropped IMAP
# connections, so you should do something to restart it when that
# happens.

import imaplib2
import time
import os
import subprocess
import email
import urllib2
import re
import sys
import multiprocessing
from threading import *

#
# Constants you may want to tune for your installation
#
MAIL_ICON='http://zachkvet.files.wordpress.com/2011/04/email-icon.png'

IMAP_USERNAME = "dave@boostpro.com"

# It will try your OSX keychain if you leave this as None
IMAP_PASSWORD = None

# Local mailboxes to scan for new unread messages
LOCAL_NOTIFY_INCOMING = ['INBOX', 'committee']

# Dovecot's imap program
PREAUTH_TUNNEL = '/opt/local/libexec/dovecot/imap'

# How many characters of a message body should we present in notifications
NOTIFY_MAX_BODY_LENGTH = 100

# sync email every 5 minutes, regardless of IDLE
SYNC_INTERVAL = 5*60 

# If any sync goes on for more than a minute, kill it
SYNC_TIMEOUT = 60 

try:
    import gntp.notifier # Growl notifications for MacOS
except:
    class Notifier(object):
        def notify(self, *args, **kw):
            pass
    notifier = Notifier()
else:
    notifier = gntp.notifier.GrowlNotifier(
        applicationName = 'Emacs',
        notifications = ['NewMessage'],
        defaultNotifications = ['NewMessage'])
    notifier.register()

def log(*args):
    if not '--verbose' in sys.argv:
        return
    print >>sys.stderr, '###',
    for a in args:
        print >>sys.stderr, a,
    print >>sys.stderr
    sys.stderr.flush()

#
# Grab the password from the keychain to avoid exposing it as plain text
#
def osxkeychain(service, account = None, type="internet"):
    acct = account and [ '-a', account ] or []
    args = ['/usr/bin/security', 'find-'+type+'-password', '-gs', service] + acct
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
    lines = p.stderr.readlines()
    return lines[0].split('"')[1]

def text_part(msg):
    maintype = msg.get_content_maintype()
    if maintype == 'text':
        return msg
    elif maintype == 'multipart':
        for part in msg.get_payload():
            found = text_part(part)
            if found:
                return found

def message_text(msg):
    text = text_part(msg)
    return text.get_payload(decode=True).replace('\r','') if text else ''

def sender(msg):
    return re.sub(r'([^<]+?)(\s+<[^@<>]+@[^@<>]+>)$', r'\1', msg['from'])

class ReadOnlyRetryConnection(object):
    def __init__(self, class_, *args, **kw):
        self.__class = class_
        self.__args = args
        self.__kw = dict(kw)
        self.__username = self.__kw.pop('username', None)
        self.__password = self.__kw.pop('password', None)
        self.__mailbox = self.__kw.pop('mailbox', None)
        self.__connection = None
        #self.__kw['debug'] = 9
        #self.__kw['debug_buf_lvl'] = 9

    def examine(self, *args, **kw):
        self.__command('examine', *args, **kw)
        self.__mailbox = args[0]

    def select(self, *args, **kw):
        self.examine(*args, **kw)

    def idle(self, *args, **kw):
        log('inner_idle', (args, kw))
        
        # idle needs special handling, because its errors don't demand an immediate retry
        self.__prepare()
        self.__connection.idle(*args, **kw)
        log('inner_idle done')

    def __prepare(self):
        if self.__connection is None:
            self.__connection = self.__class(*self.__args, **self.__kw)
        if self.__connection.state == 'NONAUTH':
            self.__connection.login(self.__username, self.__password)
        if self.__mailbox and self.__connection.state != 'SELECTED':
            mailbox = self.__mailbox
            # temporarily unset the mailbox to avoid an infinite recursion
            self.__mailbox = None
            try:
                self.examine(mailbox)
            finally:
                self.__mailbox = mailbox

    def __getattr__(self, attr):
        self.__prepare()
        a = getattr(self.__connection, attr)
        if not isinstance(a, type(self.__getattr__)):
            return a
        return lambda *args, **kw: self.__command(attr, *args, **kw)

    def __command(self, cmd, *args, **kw):
        self.__prepare()
        error_count = 0
        
        while True:
            try:
                self.__prepare()
                return getattr(self.__connection, cmd)(*args, **kw)
            except self.__connection.abort:
                if error_count > 0:
                    raise
                error_count += 1 
                # reset the connection
                self.__exit__()

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        c = self.__connection
        if c:
            self.__connection = None
            try:
                c.logout()
            except c.error:
                pass

def unseen_uids(connection, mailbox_name):
    connection.examine(mailbox_name)
    ok, messages = connection.uid('search', None, 'UNSEEN')
    return set(int(x) for x in messages[0].split())

def dns_up():
    return os.name == 'nt' or os.path.exists('/etc/resolv.conf')

class Contexts(object):
    def __init__(self, *args):
        self.children = args
        self.entered = []

    def __enter__(self):
        for c in self.children:
            c.__enter__()
            self.entered.append(c)
        return self

    def __exit__(self, type, value, tb):
        while self.entered:
            c = self.entered.pop()
            c.__exit__(type, value, tb)

class ScopedLock(object):
    def __init__(self, mutex):
        self.mutex = mutex
    def __enter__(self):
        self.mutex.acquire()
        return self
    def __exit__(self, type, value, tb):
        self.mutex.release()

class Synchronizer(Contexts):
    exc_info = None
    need_sync = False
    
    def __init__(self):
        self.local = ReadOnlyRetryConnection(imaplib2.IMAP4_stream, PREAUTH_TUNNEL)
        self.remote = ReadOnlyRetryConnection(
                    imaplib2.IMAP4_SSL, "imap.gmail.com",
                    username=IMAP_USERNAME,
                    password=IMAP_PASSWORD or osxkeychain('imap.gmail.com', IMAP_USERNAME),
                    mailbox='[Gmail]/All Mail'
                    )
        super(Synchronizer,self).__init__(self.local, self.remote)
        self.idle_done = Event()
        self.pool = multiprocessing.Pool()

    def check_error(self):
        x = self.exc_info
        self.exc_info = None
        if x:
            raise x[0], x[1], x[2]

    def idle_callback(self, args):
        log('idle_callback', self, args)
        result, data, error = args
        try:
            # According to the imaplib2 docs:
            #
            #        "abort" exceptions imply the connection should be
            #        reset, and the command re-tried.
            # 
            # Therefore, we treat those as if idling had succeeded
            if error and not isinstance(error[0], self.remote.abort):
                raise error[0], error[1]
            self.need_sync = True
        except:
            self.exc_info = sys.exc_info()
        self.idle_done.set()

    def synchronize(self):
        if not self.need_sync:
            log("no sync needed")
        while self.need_sync and dns_up():
            log("sync needed")
            self.need_sync = False
            self.pool.apply_async(
                subprocess.check_call, (['mbsync', '-a'],), {}, self.notify )
            log("sync launched")


    def notify(self, _):
        for mailbox, uids in self.local_known_uids.items():
            new_unseen = unseen_uids(self.local, mailbox) - uids
            uids |= new_unseen
            for uid in sorted(new_unseen):

                # Don't fetch more than 10K
                ok, ((open, rfc822), close) = self.local.uid('fetch', uid, '(BODY.PEEK[]<0.10240>)')

                # Was the message likely truncated?
                if open.split()[-1] == '{10240}':
                    # if so, drop the last line to aid decoding
                    rfc822 = rfc822.rsplit('/r/n',1)[0]

                message = email.message_from_string(rfc822)

                text = message_text(message)
                description = text[:NOTIFY_MAX_BODY_LENGTH]
                if description != text:
                    description += 'â€¦'

                notifier.notify(
                    noteType = 'NewMessage',
                    title = sender(message) + ': ' + message['subject'],
                    description = description,
                    icon = MAIL_ICON,
                    sticky = False,
                    priority = 1,
                    )
            
    def run(self):
        idle_timeout = 0 # initial sync is immediate
        self.local_known_uids = dict(
            ((mailbox, unseen_uids(self.local, mailbox)) for mailbox in LOCAL_NOTIFY_INCOMING))

        while dns_up():
            log('idling')
            self.idle_done.clear()
            self.remote.idle(timeout=idle_timeout, callback=self.idle_callback)
            log('waiting')
            self.idle_done.wait()
            log('check_error')
            self.check_error()
            self.synchronize()

            idle_timeout = SYNC_INTERVAL

with Synchronizer() as s:
    s.run()
