#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This code is largely based on
# http://www.cocoaforge.com/viewtopic.php?f=45&t=20355
# http://yuji.wordpress.com/2011/06/22/python-imaplib-imap-example-with-gmail/
# was also very helpful.
#
# It will exit with an error occasionally due to dropped IMAP
# connections, so you should do something to restart it when that
# happens.

import imaplib2
import time
import os
import subprocess
import email
import urllib2
import re
from threading import *

#
# Constants you may want to tune for your installation
#
MAIL_ICON='http://zachkvet.files.wordpress.com/2011/04/email-icon.png'

IMAP_USERNAME = "dave@boostpro.com"

# It will try your OSX keychain if you leave this as None
IMAP_PASSWORD = None

# Local mailboxes to scan for new unread messages
LOCAL_NOTIFY_INCOMING = ['INBOX', 'committee']

# Dovecot's imap program
PREAUTH_TUNNEL = '/opt/local/libexec/dovecot/imap'

# How many characters of a message body should we present in notifications
NOTIFY_MAX_BODY_LENGTH = 100

# sync email every 5 minutes, regardless of IDLE
SYNC_INTERVAL = 5*60 

# If any sync goes on for more than a minute, kill it
SYNC_TIMEOUT = 60 

try:
    import gntp.notifier # Growl notifications for MacOS
except:
    class Notifier(object):
        def notify(self, *args, **kw):
            pass
    notifier = Notifier()
else:
    notifier = gntp.notifier.GrowlNotifier(
        applicationName = 'Emacs',
        notifications = ['NewMessage'],
        defaultNotifications = ['NewMessage'])
    notifier.register()

#
# Grab the password from the keychain to avoid exposing it as plain text
#
def osxkeychain(service, account = None, type="internet"):
    acct = account and [ '-a', account ] or []
    args = ['/usr/bin/security', 'find-'+type+'-password', '-gs', service] + acct
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
    lines = p.stderr.readlines()
    return lines[0].split('"')[1]

def text_part(msg):
    maintype = msg.get_content_maintype()
    if maintype == 'text':
        return msg
    elif maintype == 'multipart':
        for part in msg.get_payload():
            found = text_part(part)
            if found:
                return found

def message_text(msg):
    text = text_part(msg)
    return text.get_payload(decode=True).replace('\r','') if text else ''

def sender(msg):
    return re.sub(r'([^<]+?)(\s+<[^@<>]+@[^@<>]+>)$', r'\1', msg['from'])

# This is the threading object that does all the waiting on 
# the event
class Idler(object):
    def __init__(self, local, remote, local_known_uids):
        self.thread = None
        self.local = local
        self.remote = remote
        self.local_known_uids = local_known_uids
        self.event = Event()
        self.last_notify = ""
        self.started = False
 
    def start(self):
        self.thread = Thread(target=self.idle)
        self.thread.start()
 
    def stop(self):
        # This is a neat trick to make thread end. Took me a 
        # while to figure that one out!
        self.event.set()
 
    def join(self):
        if self.thread:
            self.thread.join()
            self.thread = None
 
    def idle(self):
        # Do this as long as there's a DNS address
        while True:
            # This is part of the trick to make the loop stop 
            # when the stop() command is given
            if self.event.isSet():
                return

            self.needsync = False

            # A callback method that gets called when a new 
            # email arrives. Very basic, but that's good.
            def callback(args):
                if not self.event.isSet():
                    self.needsync = True
                    self.event.set()

            # Do the actual idle call. This returns immediately, 
            # since it's asynchronous.
            self.remote.idle(timeout=SYNC_INTERVAL, callback=callback)

            # This waits until the event is set. The event is 
            # set by the callback, when the server 'answers' 
            # the idle call and the callback function gets 
            # called.
            self.event.wait()

            # Because the function sets the needsync variable,
            # this helps escape the loop without doing 
            # anything if the stop() is called. Kinda neat 
            # solution.
            if self.needsync:
                self.event.clear()
                self.dosync()
 
    # The method that gets called when a new email arrives. 
    def dosync(self):
        # Do this as long as there's a DNS address
        if not os.path.exists('/etc/resolv.conf'):
            print '## No network; skipping sync'
            self.event.set() # Mark ourselves as needing to exit
            return

        print '## Triggering sync'
        p = subprocess.Popen(['mbsync', '-a'])
        thread = Thread(target = p.wait())
        thread.start()
        thread.join(SYNC_TIMEOUT)
        if thread.is_alive():
            p.kill()
        else:
            for mailbox, uids in self.local_known_uids.items():
                new_unseen = unseen_uids(self.local, mailbox) - uids
                uids |= new_unseen
                for uid in sorted(new_unseen):

                    # Don't fetch more than 10K
                    ok, ((open, rfc822), close) = self.local.uid('fetch', uid, '(BODY.PEEK[]<0.10240>)')

                    # Was the message likely truncated?
                    if open.split()[-1] == '{10240}':
                        # if so, drop the last line to aid decoding
                        rfc822 = rfc822.rsplit('/r/n',1)[0]

                    message = email.message_from_string(rfc822)
                    
                    text = message_text(message)
                    description = text[:NOTIFY_MAX_BODY_LENGTH]
                    if description != text:
                        description += 'â€¦'

                    notifier.notify(
                        noteType = 'NewMessage',
                        title = sender(message) + ': ' + message['subject'],
                        description = description,
                        icon = MAIL_ICON,
                        sticky = False,
                        priority = 1,
                        )

        subprocess.Popen(['doveadm','-v', 'index','[Gmail]/All Mail'])
        return
 
def unseen_uids(connection, mailbox):
    connection.examine(mailbox)
    ok, messages = connection.uid('search', None,'UNSEEN')
    return set(int(x) for x in messages[0].split())

idler = None
last_notify = ""
try:
    local = imaplib2.IMAP4_stream(PREAUTH_TUNNEL)
    local_known_uids = dict(
        ((mailbox, unseen_uids(local, mailbox)) for mailbox in LOCAL_NOTIFY_INCOMING))

    # loop forever, timing out faster than IMAP will time you out
    while os.path.exists('/etc/resolv.conf'):
        # Set the following two lines to your creds and server
        remote = imaplib2.IMAP4_SSL("imap.gmail.com")
        remote.login(IMAP_USERNAME, 
                     IMAP_PASSWORD or osxkeychain('imap.gmail.com', IMAP_USERNAME))

        # defaults to inbox
        remote.select('[Gmail]/All Mail')

        # Start the Idler thread
        idler = Idler(local, remote, local_known_uids)
        idler.last_notify = last_notify
        if last_notify == "":
            idler.dosync() # Always sync once when starting up
        print "Connected. Waiting on IDLE."
        idler.start()

        # sleep 20 minutes. Idle can time out in 30 minutes, so we'll
        # try to reconnect before then
        time.sleep(22*60)
        
        # a hack to make sure you only get notified once per email
        last_notify = idler.last_notify
        idler.stop()
        idler.join()
        remote.close()
        remote.logout()
        idler = None
finally:
    # Clean up.
    if idler is not None:
        print "Shutting down"
        idler.stop()
        idler.join()
        remote.close()
        remote.logout()
