#!/usr/bin/env python

# This code is largely based on http://www.cocoaforge.com/viewtopic.php?f=45&t=20355
#
# It will exit with an error occasionally due to dropped IMAP
# connections, so you should do something to restart it when that
# happens.

import imaplib2
import time
import os
import subprocess
import email
from threading import *

IMAP_USERNAME = "dave@boostpro.com"

#
# Grab the password from the keychain to avoid exposing it as plain text
#
def osxkeychain(service, account = None, type="internet"):
    acct = account and [ '-a', account ] or []
    args = ['/usr/bin/security', 'find-'+type+'-password', '-gs', service] + acct
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
    lines = p.stderr.readlines()
    return lines[0].split('"')[1]

IMAP_PASSWORD = osxkeychain('imap.gmail.com', IMAP_USERNAME)

SYNC_INTERVAL = 5*60 # sync email every 5 minutes, regardless of IDLE

SYNC_TIMEOUT = 60 # If any sync goes on for more than a minute, kill it

# This is the threading object that does all the waiting on 
# the event
class Idler(object):
    def __init__(self, conn):
        self.thread = None
        self.M = conn
        self.event = Event()
        self.last_notify = ""
        self.started = False
 
    def start(self):
        self.thread = Thread(target=self.idle)
        self.thread.start()
 
    def stop(self):
        # This is a neat trick to make thread end. Took me a 
        # while to figure that one out!
        self.event.set()
 
    def join(self):
        if self.thread:
            self.thread.join()
            self.thread = None
 
    def idle(self):
        # Do this as long as there's a DNS address
        while True:
            # This is part of the trick to make the loop stop 
            # when the stop() command is given
            if self.event.isSet():
                return

            self.needsync = False

            # A callback method that gets called when a new 
            # email arrives. Very basic, but that's good.
            def callback(args):
                if not self.event.isSet():
                    self.needsync = True
                    self.event.set()

            # Do the actual idle call. This returns immediately, 
            # since it's asynchronous.
            self.M.idle(timeout=SYNC_INTERVAL, callback=callback)

            # This waits until the event is set. The event is 
            # set by the callback, when the server 'answers' 
            # the idle call and the callback function gets 
            # called.
            self.event.wait()

            # Because the function sets the needsync variable,
            # this helps escape the loop without doing 
            # anything if the stop() is called. Kinda neat 
            # solution.
            if self.needsync:
                self.event.clear()
                self.dosync()
 
    # The method that gets called when a new email arrives. 
    def dosync(self):
        # Do this as long as there's a DNS address
        if not os.path.exists('/etc/resolv.conf'):
            print '## No network; skipping sync'
            self.event.set() # Mark ourselves as needing to exit
            return

        print '## Triggering sync'
        p = subprocess.Popen(['mbsync', '-a'])
        thread = Thread(target = p.wait())
        thread.start()
        thread.join(SYNC_TIMEOUT)
        if thread.is_alive():
            p.kill()
        subprocess.Popen(['doveadm','-v', 'index','[Gmail]/All Mail'])
        return
        
        print "Got an event!" 
        retcode, messages = self.M.search(None, 'UNSEEN')
        if len(messages) >= 1 and len(messages[0].split()) >= 1:
            ret, msginfo = self.M.fetch(messages[0].split()[-1], '(BODY[HEADER.FIELDS (SUBJECT FROM)] BODY[1])')
            if ret == 'OK':
                header = msginfo[0][1].split('\r\n')
                sender = header[0]
                subject = header[1][9:]
                body = msginfo[1][1][:100]
                notify = sender+subject+body
                if notify != self.last_notify:
                    self.last_notify = notify
                    print "New email %s %s %s" % (sender,subject,body)
                else:
                    print "Already notified"
 
idler = None
last_notify = ""
try:
    # loop forever, timing out faster than IMAP will time you out
    while os.path.exists('/etc/resolv.conf'):
        # Set the following two lines to your creds and server
        M = imaplib2.IMAP4_SSL("imap.gmail.com")
        M.login(IMAP_USERNAME, IMAP_PASSWORD)

        # defaults to inbox
        M.select('[Gmail]/All Mail')

        # Start the Idler thread
        idler = Idler(M)
        idler.last_notify = last_notify
        if last_notify == "":
            idler.dosync() # Always sync once when starting up
        print "Connected. Waiting on IDLE."
        idler.start()

        # sleep 20 minutes. Idle can time out in 30 minutes, so we'll
        # try to reconnect before then
        time.sleep(22*60)
        
        # a hack to make sure you only get notified once per email
        last_notify = idler.last_notify
        idler.stop()
        idler.join()
        M.close()
        M.logout()
        idler = None
finally:
    # Clean up.
    if idler is not None:
        print "Shutting down"
        idler.stop()
        idler.join()
        M.close()
        M.logout()
